[toc]

# c++核心编程

## 1 内存分区模型

c++程序在执行是，将内存大方向划分为 4 个区域

- 代码区：存放函数体的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
- 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

内存四区意义：

不同区域存放的数据，赋予不同的声明周期，给我们更大的灵活编程

### 1.1 程序运行前

在程序编译后，生成 exe 可执行程序，未执行该程序钱分为两个区域

**代码区：**

> 存放 cpu 执行的机器指令
>
> 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
>
> 代码区是只读的，使其只读的原因是防止程序意外地修改了他的指令

**全局区：**

> 全局变量和静态变量存放在此
>
> 全局区还包含了常量区，字符串常量和其他常量也存放在此
>
> 该区域的数据在程序结束后由操作系统释放

```c++
#include <iostream>
using namespace std;
#include "string"
//全局变量
int g_a=10;
int g_b=10;
//全局常量
const int c_g_a=10;
const int c_g_b=10;
int main() {
    //全局区
    //全局变量，静态变量，常量
    //创建普通局部变量
    int a=10;
    int b=10;
    cout<<"局部变量a的地址为："<<&a<<endl;
    cout<<"局部变量b的地址为："<<&b<<endl;

    cout<<"全局变量g_a的地址为："<<&g_a<<endl;
    cout<<"全局变量g_b的地址为："<<&g_b<<endl;

    //静态变量  在普通变量前加上static，属于静态变量
    static int s_a=10;
    static int s_b=10;
    cout<<"静态变量s_a的地址为："<<&s_a<<endl;
    cout<<"静态变量s_b的地址为："<<&s_b<<endl;

    //常量
    //字符串常量
    cout<<"字符串常量地址为："<<&"hello world"<<endl;
    //const修饰的变量,const修饰的全局变量，const修饰的局部变量
    cout<<"const修饰的全局常量c_g_a的地址为："<<&c_g_a<<endl;
    cout<<"const修饰的全局常量c_g_b的地址为："<<&c_g_b<<endl;

    const int c_a=10;
    const int c_b=10;
    cout<<"const修饰的局部常量c_a的地址为："<<&c_a<<endl;
    cout<<"const修饰的局部常量c_b的地址为："<<&c_b<<endl;
    system("pause");
    return 0;
}
```

总结：

- c++在程序运行前分全局区和代码区
- 代码区特点是共享和只读
- 全局区中存放全局变量，静态变量，常量
- 常量区中存放 const 修饰的全局常量和字符串常量

### 1.2 程序运行后

栈区：

> 由编译器自动分配释放，存放函数的参数值，局部变量等
>
> 注意事项：不要反回局部变量的地址，栈区开辟的数据有编译器自动释放

堆区：

> 由程序员分配释放，若程序员不释放，程序结束时有操作系统回收
>
> 在 c++中主要利用 new 在堆区开辟内存

### 1.3 new 操作符

c++中利用 new 操作符在堆区开辟数据

堆区开辟的数据，有程序员手动开辟，手动释放，释放利用操作符 delete

语法： new 数据类型

利用 new 创建的数据，会返回该数据对应的类型的指针

## 2 引用

### 2.1 引用的基本使用

作用：给变量起别名

语法：数据类型 &别名=原名

示例：

```c++
int main(){
    int a=10;
    int &b=a;
    cout<<"a="<<a<<endl;
    cout<<"b="<<b<<endl;
    b=100;
    cout<<"a="<<a<<endl;
    cout<<"b="<<b<<endl;

    system("pasue");
    return 0
}
```

### 2.2 引用注意事项

- 引用必须初始化
- 引用在初始化后，不可以改变

示例：

```c++
int main(){
	int a=10;
    int b=20;
    int &c;//这是错误的，引用必须初始化
    int &c=a;//一旦初始化后，就不可以更改
    c=b;//这是赋值操作，不是更改引用
    cout<<"a="<<a<<endl;
    cout<<"b="<<b<<endl;
    cout<<"c="<<c<<endl;

    system("pasue");
    return 0;
}
```

### 2.3 引用做函数参数

作用：函数传参时，可以利用引用的技术让形参修饰实参

优点：可以简化指针修改实参

示例：

```c++
#include <iostream>
using namespace std;
//值传递
void mySwap01(int a,int b){
    int temp=a;
    a=b;
    b=temp;
    cout<<"swap01 a="<<a<<endl;
    cout<<"swap01 b="<<b<<endl;
}
//地址传递
void mySwap02(int * a,int * b){
    int temp=*a;
    *a=*b;
    *b=temp;
}
//引用传递
void mySwap03(int &a,int &b){
    int temp=a;
    a=b;
    b=temp;
}
int main() {
    int a=10;
    int b=20;
    mySwap01(a,b); //值传递，形参不会修饰实参
    cout<<"值传递a="<<a<<endl;
    cout<<"直传递b="<<b<<endl;

    mySwap02(&a,&b);//地址传递，形参会修饰实参
    cout<<"指针传递a="<<a<<endl;
    cout<<"指针传递b="<<b<<endl;

    mySwap03(a,b);//引用传递，形参会修饰实参
    cout<<"引用传递a="<<a<<endl;
    cout<<"引用传递b="<<b<<endl;
    system("pause");
    return 0;
}
```

> 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单

### 2.4 引用做函数返回值

作用：引用是可以作为函数的返回值存在的

注意：不要返回局部变量引用

用法：函数调用作为左值

示例：

```c++
int& test01(){
	int a=10;//局部变量
    return a;
}
int& test02(){
    static int a=20;//静态变量
    return a;
}
int main(){
 	//不能返回局部变量引用
    int& ref=test01();
    cout<<"ref="<<ref<<endl;//第一次可以返回，编译器做了保留
    cout<<"ref="<<ref<<endl;//第二次结果错误，因为a的内存已经释放了

    int& ref2=test02();
    cout<<"ref2="<<ref2<<endl;
    cout<<"ref2="<<ref2<<endl;

    test02()=1000;//如果函数的返回值是引用，这个函数调用可以作为左值
}
```

### 2.5 引用的本质

本质：**引用的本质在 c++内部实现是一个指针常量**

示例：

```c++
//发现是引用，转换为int* const ref=&a;
void func(int& ref){
    ref=100;//ref引用，转换为*ref=100
}
int main(){
    int a=10;
    //自动转换成int* const ref=&a;指针常量是指针指向不可以更改，也说明为什么引用不可更改
    int& ref=a;
    ref=20;//内部发现ref是引用，自动帮我们转换为*ref=20;
    cout<<"a="<<a<<endl;
    cout<<"ref="ref<<endl;
    func(a);
    return 0;
}
```

### 2.6 常量引用

作用：常量引用主要用来修饰形参，防止误操作

在函数形参列表中，可以加 const 修饰形参，防止形参改变实参

示例：

```c++
void showValue(const int& v){
	cout<<v<<endl;
}
int main(){
    //int& ref=10;引用本身需要一个合法的内存空间，因此这个运行错误
    //加入const就可以了，编译器优化代码，int temp=10;const int& ref=temp;
    const int& ref=10;
    //ref=100;//加入const后不可以修改变量
    cout<<ref<<endl;
    //函数中利用常量引用防止误操作修改实参
    int a=10;
    showValue(a);

    system("pause");
    return 0;
}
```

## 3 函数提高

### 3.1 函数默认参数

在 c++中，函数的形参列表中的形参是可以有默认值的。

语法：返回值类型 函数名 （参数=默认值）{}

```c++
#include <iostream>
using namespace std;
//函数的默认参数
int func(int a,int b,int c)
{
    return a+b+c;
}
//如果自己输入数据，就用自己的数据，如果没有，那么就用默认值

int func1(int a,int b=20,int c=30)
{
    return a+b+c;
}
//注意事项
//如果某个位置已近有了默认值，那么从这个位置往后，从左到右都必须有默认值，函数中的形参只能是定义的最后一个有默认值，否则报错
//如果函数声明有默认参数，函数实现就不能有默认参数
//声明和实现只能有一个默认的参数
int main() {
    cout<<func(10,20,30)<<endl;
    cout<<func1(10)<<endl;
    system("pause");
    return 0;
}
```

### 3.2 函数的占位参数

c++中函数的形参列表里可以有占位参数，用来做占位，调用函数是必须填补该位置

语法：返回值类型 函数名（数据类型）{}

在现阶段函数的占位参数存在意义不大，但是后面的课程会用到改技术

示例：

```c++
#include <iostream>
using namespace std;

void func(int a,int)
{
    cout<<"this is func"<<endl;
}
int main() {
    func(10,10);//占位参数必须填补
    system("pause");
    return 0;
}
```

### 3.3 函数重载

#### 3.3.1 函数重载概述

作用：函数名可以相同，提高复用性

函数重载满足条件：

- 同一个作用域下
- 函数名称相同
- 函数参数**类型不同**或者**个数不同**或者**顺序不同**

**注意：函数的返回值不可以作为函数重载的条件**

#### 3.3.2 函数重载注意事项

- 引用作为重载条件
- 函数重载碰到函数默认参数

示例：

```c++
#include <iostream>
using namespace std;

//函数重载注意事项
//引用作为重载条件
void func(int &a)
{
    cout<<"func (int &a)被调用"<<endl;
}
void func(const int &a)
{
    cout<<"func(const int &a)调用"<<endl;
}
//函数重载碰到默认参数会产生参数歧义，需要避免
int main() {
//    int a=10;
//    func(a);
    func(10);
    system("pause");
    return 0;
}
```

## 4 类和对象

c++面向对象三大特性：封装，继承，多态

c++认为万事万物皆对象，对象上有属性和行为

### 4.1 封装

#### 4.1.1 封装的意义

封装是 c++面向对象三大特性之一

封装的意义：

- 将属性和行为作为一个整体，来映射生活中的事物
- 将属性和行为加以权限控制

在设计类的时候，属性和行为写在一起，表现事物

**语法：** class 类名{访问权限：属性/行为}

示例 1：

```c++
#include <iostream>
using namespace std;

const double PI=3.14;
//设计一个圆类，请圆的周长
class Circle
{
    //访问权限
    //公共权限
public:
    //属性
    int m_R;//半径
    //行为
    //获取圆的周长
    double calclezc(){
        return 2*PI*m_R;
    }
};
int main() {
    //通过圆类，创建具体的圆（对象）
    Circle c1;
    //给圆的（半径）对象赋值
    c1.m_R=3;
    cout<<c1.calclezc()<<endl;
    system("pause");
    return 0;
}
```

示例 2：

```c++
#include <iostream>
using namespace std;

#include "string"
//设计一个圆类，请圆的周长
class Student
{
    //公共权限
public:
    //属性
    string name;
    int id;
    //行为：显示姓名和学号
    void showStudent(){
        cout<<"  学生学号："<<name<<"  学生姓名："<<id<<endl;
    }
};
int main() {
    Student stu;
    stu.name="张三";
    stu.id=10001;
    stu.showStudent();
    system("pause");
    return 0;
}
```

类在设计是，可以吧属性和行为放在不同的权限下，加以控制

访问权限有三种

| 语法      | 权限     | 作用                         |
| --------- | -------- | ---------------------------- |
| public    | 公共权限 | 类内可以访问，类外可以访问   |
| protected | 保护权限 | 类内可以访问，类外不可以访问 |
| private   | 私有权限 | 类内可以访问，类外不可以访问 |

```c++
#include <iostream>
using namespace std;

#include "string"
class Person
{
    //公共权限
public:
    string name;
    //保护权限
protected:
    string car;
private:
    int password;
public:
    void func(){
        name="张三";
        car="本田";
        password:123456;
    }
};
int main() {
    //实例化居停对象
    Person p1;
    p1.name="李四";
//    p1.car="奔驰";//保护权限对象外面不能访问
//    p1.password=4587547;//私有的外面不能访问
    p1.func();
    system("pause");
    return 0;
}
```

#### 4.1.2 struct 和 class 区别

在 c++中 struct 和 class 唯一区别就在于默认的访问权限不同

区别：

- struct 默认权限为公共
- class 默认权限为私有

#### 4.1.3 成员属性设置为私有

优点 1：将所有成员属性设置为私有，可以自己控制读写权限

优点 2：对于写权限，我们可以检测数据的有效性

示例：

```c++
#include <iostream>
using namespace std;

#include "string"
//成员属性设置为私有
class Person
{
public:
    //设置姓名
    void setName(string name)
    {
        m_Name=name;
    }
    //获取名字
    string getName()
    {
        return m_Name;
    }
    //获取年龄
    int getAge(){
        m_Age=0;  //初始化为0
        return m_Age;
    }
private:
    //姓名  可读可写
   string m_Name;
    //年龄  只读
   int m_Age;
   //情人  只写
   int m_Lover;
};
int main() {
    Person p;
    p.setName("张三");
    cout<<"姓名为： "<< p.getName()<<endl;
    cout<<"年龄为："<<p.getAge()<<endl;
    system("pause");
    return 0;
}
```

> 设置只读或者只写或者可读可写的模式就是在定义类时加上 get 和 set 方法就可以了。
>
> 同时也可以加上判断方法，列如在年龄中只写的话可以用 if 语句判断年龄是否大于 0 小于 150，如果是者输出，如果不是则打印错误信息

##### 练习案例 1：设置立方体类

设置立方体类 Cube

求出立方体的面积和体积

分布用全局函数和成员函数判断两个立方体是否相等

```c++
#include <iostream>
using namespace std;

#include "string"
//设置立方体类
class Cube
{
public:
    //设置长
    void setML(int l)
    {
        m_L=l;
    }
    //获取长
    int getML(){
        return m_L;
    }
    //设置宽
    void setMW(int w)
    {
        m_W=w;
    }
    //获取宽
    int getMW(){
        return m_W;
    }
    //设置高
    void setMH(int h){
        m_H=h;
    }
    //获取高
    int getMH(){
        return m_H;
    }
    //获取立方体的体积
    int cubetj(){
        return m_H*m_W*m_L;
    }
    //获取立方体的面积
    int cubemj(){
        return 2*m_L*m_W+2*m_L*m_H+2*m_W*m_H;
    }
    //利用成员函数判断两个立方体是否相等
    bool isSameByClass(Cube &c){
        if(m_L==c.getML()&&m_W==c.getMW()&&m_H==c.getMH()){
            return true;
        }
        return false;
    }
private:
    //长
    int m_L;
    //宽
    int m_W;
    //高
    int m_H;
};
//利用全局函数判断 两个立方体是否相等
bool isSame(Cube &c1,Cube &c2){
    if(c1.getML()==c2.getML()&&c1.getMW()==c2.getMW()&&c1.getMH()==c2.getMH()){
        return true;
    }
    return false;
}
int main() {
    //创建立方体对象
    Cube c1;
    c1.setML(10);
    c1.setMW(10);
    c1.setMH(20);
    cout<<"c1的面积为："<<c1.cubemj()<<endl;
    cout<<"c1的体积为："<<c1.cubetj()<<endl;

    //创建第二个立方体
    Cube c2;
    c2.setMW(10);
    c2.setML(15);
    c2.setMH(10);

    bool ret=isSame(c1,c2);
    if(ret)
    {
        cout<<"全局函数c1和c2相等"<<endl;
    }else{
        cout<<"全局函数c1和c2不相等"<<endl;
    }

    ret =c1.isSameByClass(c2);
    if(ret)
    {
        cout<<"成员函数c1和c2相等"<<endl;
    }else{
        cout<<"成员函数c1和c2不相等"<<endl;
    }
    system("pause");
    return 0;
}
```

##### 练习案例 2：点和圆的关系

设计一个圆类，和一个点类，计算点和圆的关系

```c++
main.cpp打印页面
#include <iostream>
using namespace std;

#include "point.h" //导入点类的头文件
#include "circle.h" //导入圆类的头文件
//设置立方体类
//点和圆关系判断
//点到圆心的距离==半径  点在圆上
//点到圆心的距离>半径   点在圆外
//点到圆心的距离<半径     点在圆内

//判断点和圆的关系
void isInCircle(Circle &c,Point &p){
    //计算两点之间距离  平方
    int distance=
    (c.getCenter().getX()-p.getX())*(c.getCenter().getX()-p.getX())+
    (c.getCenter().getY()-p.getY())*(c.getCenter().getY()-p.getY());
    //计算半径的平方
    int rDistance =c.getR()*c.getR();
    //判断关系
    if(distance==rDistance)
    {
        cout<<"点在圆上"<<endl;
    }
    else if(distance>rDistance)
    {
        cout<<"点在圆外"<<endl;
    }
    else if(distance<rDistance)
    {
        cout<<"点在圆内"<<endl;
    }
}
int main() {
    //创建圆
    Circle c;
    c.setR(10);
    Point center;
    center.setX(10);
    center.setY(0);
    c.setCenter(center);
    //创建点
    Point p;
    p.setX(10);
    p.setY(10);
    //判断关系
    isInCircle(c,p);
    system("pause");
    return 0;
}
```

```c++
circle.cpp页面
#include "circle.h"
//圆类
//设置半径
void Circle::setR(int r){
    m_R=r;
}
//获取半径
int Circle::getR(){
    return m_R;
}
//设置圆心
void Circle::setCenter(Point center){
    m_Center=center;
}
//获取圆心
Point Circle::getCenter(){
    return m_Center;
}


circle.h页面
#pragma once

#include <iostream>
#include "point.h"
using namespace std;
//圆类
class Circle
{
public:
    //设置半径
    void setR(int r);
    //获取半径
    int getR();
    //设置圆心
    void setCenter(Point center);
    //获取圆心
    Point getCenter();
private:
    int m_R; //半径
    Point m_Center;//圆心
};
```

```c++
point.cpp页面
#include "point.h"
//设置x
void Point::setX(int x){
    m_X=x;
}
//获取x
int Point::getX(){
    return m_X;
}
//设置y
void Point::setY(int y){
    m_Y=y;
}
//获取y
int Point::getY(){
    return m_Y;
}

point.h页面
#pragma once

#include <iostream>
using namespace std;
//点类
class Point
{
public:
    //设置x
    void setX(int x);
    //获取x
    int getX();
    //设置y
    void setY(int y);
    //获取y
    int getY();
private:
    int m_X;
    int m_Y;
};
```

### 4.2 对象的初始化和清理

- 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用是后也会删除一些我们自己的信息数据保证安全
- c++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置

#### 4.2.1 构造函数和析构函数

对象的初始化和清理也是两个非常重要的安全问题

​ 一般对象或者变脸没有初始状态，对其使用后果是未知

​ 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

c++利用管理构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作，

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供。编译器提供的构造函数和析构函数是空实现的。

- 构造函数：主要作用在与创建对象是为对象的成员属性赋值，构造函数有编译器自动调用，无须手动调用
- 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作

**构造函数语法：** 类名(){}

1.构造函数，没有返回值也不写 void

2.函数名称与类名相同

3.构造函数可以有参数，因此可以发生重载

4.程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次

**析构函数语法：** ~类名(){}

1.析构函数，没有返回值也不写 void

2.函数名称与类名相同，在名称前加上符号~

3.析构行数不可以有参数，因此不可以发生重载

4.程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次

```c++
//对象的初始化和清理
//1.构造函数  进行初始化操作
calss Person
{
public:
	//1.1 构造函数
	Person()
	{
		cout<<"Person构造函数的调用"<<endl;
	}
	//1.2 析构函数  进行清理的操作
	~Person()
	{
		cout<<"Person析构函数的调用"<<endl;
	}
}
//构造函数和析构函数都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现的构造和析构
void test01()
{
    //在栈上的数据，test01执行完毕后，释放这个对象
	Person p;
}

int main(){
	//test01();
    Person p;
	system("pause");
	return 0;
}
```

#### 4.2.2 构造函数的分类及调用

两种分类方式：

> 按参数分为：有参构造和无参构造
>
> 按类型分为：普通构造和拷贝构造

三种调用方式：

> 括号法
>
> 显示法
>
> 隐式转换法

示例：

```c++
//构造函数的分类及调用
//分类
class Person{
    public:
    //构造函数  无参
    Person(){
        cout<<"无参Person的构造函数调用"<<endl;
    }
    //构造函数  有参
    Person(int a){
        age=a;
       cout<<"有参Person的构造函数调用"<<endl;
    }
    //拷贝构造函数
    Person(const Person &p){
        //将转入的人身上的所有属性，拷贝到我身上
        age=p.age;
        cout<<"拷贝Person的构造函数调用"<<endl;
    }
    //析构函数
    ~Person(){
        cout<<"Person的析构函数调用"<<endl;
    }
    int age;
}
//调用
void test01(){
    //括号法
    Person p1;//默认构造函数调用
    Person p2(10);//有参构造函数
    person p2(p2);//拷贝构造函数

    //显示法
    Person p1;
    Person p2=Person(10);//有参构造
    Person p3=Person(p2);//拷贝构造
    Person(10);//匿名对象  特点：当前执行结束后，西宫会立即回收掉匿名对象
    //不要利用拷贝构造函数  初始化匿名对象

    //隐式转换法
    Person p4=10; //相当于写了 Person p4=Person(10)
    Person p5=p4;//拷贝构造
}
int main(){
    test01();
    system("pause");
    return 0;
}
```

#### 4.2.3 拷贝构造函数调用时机

c++中拷贝构造调用时机通常有三种情况

- 使用一个已经创建完毕的对象来初始化一个新对象
- 值传递的方式给函数参数传值
- 以值方式返回局部对象

```c++
class Person{
    public:
    Person(){
        cout<<"无参构造函数"<<endl;
 		m_Age=0;
    }
    Person(int age){
        cout<<"有参构造函数"<<endl;
 		m_Age=age;
    }
    Person(const Person &p)
    {
        cout<<"拷贝构造函数"<<endl;
        m_Age=p.mAge;
    }
    ~Person(){
         cout<<"析构函数"<<endl;
    }
    int m_Age
}
//使用一个已经创建完毕的对象来初始化一个新对象
void test01()
{
    Person p1(20);
    Person p2(p1)
}
//值传递的方式给函数参数传值
void doWork(Person p)
{

}
void test02()
{
    Person p;
    doWork(p);
}
//值方式返回局部对象
Person doWork2()
{
    Person p1;
    cout<<(int*)&p1<<endl;
    return p1;
}
void test03(){
    Person p=doWork2();
    cout<<(int*)&p<<endl;
}
int main(){
    test01();
    test02();
    test03();
    system("pause");
    return 0;
}

```

#### 4.2.4 构造函数调用规则

默认情况下，c++编译器至少给一个类添加 3 个函数

- 默认构造函数(无参，函数体为空)
- 默认析构函数(无参，函数体为空)
- 默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下：

- 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造
- 如果用户定义拷贝构造函数，c++不会再提供其他构造函数

示例：

```c++
class Person{
    public:
    Person(){
        cout<<"无参构造函数"<<endl;
 		m_Age=0;
    }
    Person(int age){
        cout<<"有参构造函数"<<endl;
 		m_Age=age;
    }
    Person(const Person &p)
    {
        cout<<"拷贝构造函数"<<endl;
        m_Age=p.mAge;
    }
    ~Person(){
         cout<<"析构函数"<<endl;
    }
    int m_Age
}
void test03(){
    Person p=doWork2();
    cout<<(int*)&p<<endl;
}
int main(){
    test03();
    system("pause");
    return 0;
}
```

#### 4.2.5 深拷贝与浅拷贝

深拷贝是面试经典问题，也是常见的一个坑

浅拷贝：简单的赋值拷贝操作

深拷贝：在堆区重新申请空间，进行拷贝操作

```c++
#include <iostream>
using namespace std;

//深拷贝与浅拷贝
class Person
{
public:
    Person(){
        cout<<"Person的默认构造函数调用"<<endl;
    }
    Person(int age,int height)
    {
        m_Height=new int(height);
        m_Age=age;
        cout<<"Person的有参构造函数调用"<<endl;
    }
    //实现拷贝构造函数 解决浅拷贝带来的问题
    Person(const Person &p)
    {
        cout<<"Person的有参构造函数调用"<<endl;
        m_Age=p.m_Age;
        //m_Height=p.,_Height;编译器默认实现这是这行代码
        //深拷贝操作
        m_Height=new int (*p.m_Height);
    }
    ~Person(){
        //析构函数将堆区开辟的数据做释放操作
        //浅拷贝带来的问题就是堆区的内存重复释放
        if(m_Height!=NULL)
        {
            delete m_Height;
            m_Height=NULL;
        }
        cout<<"Person的析构函数调用"<<endl;
    }
    int m_Age;
    int *m_Height;
};
void test01(){
    Person p1(10,170);
    cout<<"p1的年龄为："<<p1.m_Age<<"p1的身高为："<<*p1.m_Height<<endl;

    Person p2(p1);
    //如果利用编译器提供的拷贝构造函数，会做浅拷贝操作
    cout<<"p2的年龄为："<<p2.m_Age<<"p2的身高为："<<*p2.m_Height<<endl;
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

> 总结：如果属性有在堆区开辟的，一定要提供拷贝构造函数，防止浅拷贝带来的问题

#### 4.2.6 初始化列表

作用：c++提供了初始化列表语法，用来初始化属性

语法：构造函数():属性 1(值 1)，属性 2(值 2)...{}

示例：

```c++
#include <iostream>
using namespace std;

//初始化列表
class Person
{
public:
    //传统初始化操作
//    Person(int a,int b,int c){
//        m_A=a;
//        m_B=b;
//        m_C=c;
//    }
    //初始化列表初始化属性
    Person():m_A(10),m_B(20),m_C(30){};
    int m_A;
    int m_B;
    int m_C;
};
void test01(){
//    Person p(10,20,30);
    Person p;
    cout<<"m_A= "<<p.m_A<<endl;
    cout<<"m_B= "<<p.m_B<<endl;
    cout<<"m_C= "<<p.m_C<<endl;
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

#### 4.2.7 类对象作为类成员

c++类中的成员可以是另一个类的对象，我们称该成员为对象成员

列如：

```
class A{}
calss B
{
	A a;
}
```

B 类中有 A 作为成员，A 为对象成员

```c++
#include <iostream>
using namespace std;

#include "string"
class Phone{
public:
    Phone(string pName){
        m_pName=pName;
    }
    string m_pName;
};
class Person
{
public:
    //Phone m_Phone=p.Name  隐式转换法
    Person(string name,string pName):m_Name(name),m_Phone(pName){
        cout<<"Person的构造函数调用"<<endl;
    }
    ~Person(){
        cout<<"Person的析构函数调用"<<endl;
    }
    string m_Name;
    Phone m_Phone;

};
//当其他类对象作为本类成员，构造是先够着类对象，再构造自身，析构的顺序与构造想反
void test01(){
    Person p("张三","vivo xs");
    cout<<p.m_Name<<"拿着"<<p.m_Phone.m_pName<<endl;
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

#### 4.2.8 静态成员

静态成员就是在成员变量和成员函数钱加上关键 static，称为静态成员

静态成员分为：

- 静态成员变量

  所有对象共享同一份数据

  在编译阶段分配内存

  类内声明，类外初始化

- 静态成员函数

  所有对象共享同一个函数

  静态成员函数只能访问静态成员变量

```c++
#include <iostream>
using namespace std;

#include "string"
//所有对象共享同一个函数
//静态成员函数只能访问静态成员变量
//静态成员函数也是有访问权限的
class Person
{
public:
    //静态成员函数
    static void func(){
        m_A=100;//静态成员函数可以访问，静态成员变量
        //m_B=200;//静态成员函数 不可以访问非静态成员变量
        cout<<"static void func被调用"<<endl;
    }
    static int m_A;//静态成员变量
    int m_B;//非静态成员变量
};
int Person::m_A=0;
//当其他类对象作为本类成员，构造是先够着类对象，再构造自身，析构的顺序与构造想反
void test01(){
    //通过对象访问
    Person p;
    p.func();

    //通过类名访问
    Person::func();
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

### 4.3 c++对象模型和 this 指针

#### 4.3.1 成员变量和成员函数分开存储

在 c++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上

示例：

```c++
#include <iostream>
using namespace std;

#include "string"

class Person
{
public:
    int a;//非静态成员变量   属于类的对象上
    static int b;//静态成员变量  不属于类对象上
    void func(){}//非静态成员函数 不属于类对象上
    static void func2(){}  //静态成员函数
};
int Person::b=0;
void test01(){
    Person p;
    //空对象占用内存空间为：1
    //c++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存位置
    cout<<"size of p="<< sizeof(p)<<endl;
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

#### 4.3.2 this 指针概念

c++中成员变量和成员函数是分开储存的

没一个非静态成员函数只会诞生一份实例，也就是说多个同类型的对象会共用一块代码，

c++通过提供特殊的对象指针，this 指针，来调用或区分自己

**this 指针执行被调用的成员函数所属的对象**

this 指针是隐含每一个非静态成员函数内的一种指针

this 指针不需要定义，直接使用即可

this 指针的用途：

- 当形参和成员变量同名时，可用 this 指针来区分
- 在类的非静态成员函数中返回对象本身，可使用 return \*this

```c++
#include <iostream>
using namespace std;

#include "string"

class Person
{
public:
    Person(int age)
    {
        //this指针指向  被调用的成员函数  所属的对象
        this->age=age;
    }
    Person& PersonsonAddAGe(Person &p)
    {
        this->age+=p.age;
        //this指向p2的指针，而*this指向的就是p2这对象的本体
        return *this;
    }
   int age;
};
//解决名称冲突
void test01(){
    Person p(18);
    cout<<"p的年龄为"<<p.age<<endl;
}
//返回对象本身用*this
void test02(){
    Person p1(10);
    Person p2(10);
    //链式编程
    p2.PersonsonAddAGe(p1).PersonsonAddAGe(p1).PersonsonAddAGe(p1);
    cout<<"p2的年龄为："<<p2.age<<endl;
}
int main() {
    test01();
    test02();
    system("pause");
    return 0;
}
```

#### 4.3.3 空指针访问成员函数

c++中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针

如果用到 this 指针，需要加以判断保证代码的健壮性

```c++
#include <iostream>
using namespace std;

#include "string"

class Person
{
public:
  void showClassName()
  {
      cout<<"this is Person class"<<endl;
  }
  void showPersonAge()
  {
      //报错原因是因为传入的指针是为NULL
      if(this==NULL){
          return;
      }
      cout<<"age="<<this->m_age<<endl;
  }
  int m_age;
};
//解决名称冲突
void test01(){
    Person *p=NULL;
    p->showClassName();
    p->showPersonAge();
}

int main() {
    test01();
    system("pause");
    return 0;
}
```

#### 4.3.4 const 修饰成员函数

常函数：

- 成员函数后加 const 后我们称为这个函数为常函数
- 常函数内不可以修改成员属性
- 成员属性声明是加关键字 mutable 后，在常函数中依然可以修改

常对象：

- 声明对象前加 const 称该对象为常对象
- 常对象只能调用常函数

```c++
#include <iostream>
using namespace std;

#include "string"

class Person
{
public:
    //this指针的本质  是指针常量  指针的指向是不可以修改的
    //const Person * const this
    //在成员函数后面加const，修饰的是this指向，让指针指向的值也不可以修改
  void showPerson() const{
    //m_A=100;
    //this=NULL;//this指针不可以修改指针的指向的
    this->m_B=100;
  }
  void func(){
        m_A=100;
    }
  int m_A;
  mutable int m_B;//特殊变量，即时在长韩仲，也可以修改这个值，加上关键字mutable
};

void test01(){
    Person p;
    p.showPerson();
}
//常对象
//void test02(){
//    const Person p1;//在对象前加const，编程常对象
////    p.m_A=100;
//    p1.m_B=100;//m_B是特殊值，在对象下也可以修改
//    //常对象只能调用常函数
//    p1.showPerson();
////    p.func();//不能调用普通成员函数，因为不能修改
//}
int main() {
    test01();
//    test02();
    system("pause");
    return 0;
}
```

> 注意：在 test02 函数中存在修饰 const Person p1 报错（为知道原因）

### 4.4 友元

生活中你的家有客厅(public),有你的卧室(private)

客厅所有来的客人都可以进来，但是你的卧室是私有的，也就是说只有你能进去但是呢。你也可以允许你的好闺蜜好基友进去。

在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术

友元的目的就是让一个函数或者类 访问另一个类中私有成员

友元的关键字为 friend

友元的三种实现

- 全局函数做友元
- 类做友元
- 成员函数做友元

#### 4.4.1 全局函数做友元

```c++
#include <iostream>
using namespace std;

#include "string"

class Building
{
    //goodgay全局函数是 Building好朋友，可以访问Building中私有成员
    friend void goodGay(Building* building);
public:
    Building(){
        m_SittingRoom="客厅";
        m_BedRoom="卧室";
    }
public:
   string m_SittingRoom;
private:
    string m_BedRoom;
};
//全局函数
void goodGay(Building* building){
    cout<<"好基友全局函数 正在访问："<<building->m_SittingRoom<<endl;
    cout<<"好基友全局函数 正在访问："<<building->m_BedRoom<<endl;
}
void test01(){
    Building building;
    goodGay(&building);
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

#### 4.4.2 类做友元

```c++
#include <iostream>
using namespace std;

#include "string"
//类做友元
class Building;

class GoodGay
{
public:
    GoodGay();
    void visit();//参观函数， 访问Building中的属性
    Building *building;
};

class Building{
    //GoodGay类时本来的好基友。可以访问本类中私有成员
    friend class GoodGay;
public:
    Building();
public:
    string m_SittingRoom;
private:
    string m_BedRoom;
};
//类外写成员函数
Building::Building() {
    m_SittingRoom="客厅";
    m_BedRoom="卧室";
}
GoodGay::GoodGay() {
    //创建建筑物对象
    building=new Building;
}
void GoodGay::visit() {
    cout<<"好基友类正在访问："<<building->m_SittingRoom<<endl;
    cout<<"好基友类正在访问："<<building->m_BedRoom<<endl;
}
void test01(){
    GoodGay gg;
    gg.visit();
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

#### 4.4.3 成员函数

```c++
#include <iostream>
using namespace std;

#include "string"
//类做友元
class Building;

class GoodGay
{
public:
    GoodGay();
    void visit();//让visit可以访问Building中私有成员变量
    void visit2();//让visit2不可以访问Building中私有成员变量
    Building * building;
};

class Building{
    //告诉编译器 goodGay类下的visit成员函数作为本来的好朋友， 可以访问私有成员
    friend void GoodGay::visit();
public:
    Building();
public:
    string m_SittingRoom;
private:
    string m_BedRoom;
};

//类外写成员函数
Building::Building() {
    m_SittingRoom="客厅";
    m_BedRoom="卧室";
}
GoodGay::GoodGay() {
    //创建建筑物对象
    building=new Building;
}
void GoodGay::visit() {
    cout<<"visit函数正在访问："<<building->m_SittingRoom<<endl;
    cout<<"visit函数正在访问："<<building->m_BedRoom<<endl;
}
void GoodGay::visit2() {
    cout<<"visit2函数正在访问："<<building->m_SittingRoom<<endl;
    //cout<<"visit2函数正在访问："<<building->m_BedRoom<<endl;
}
void test01(){
    GoodGay gg;
    gg.visit();
    gg.visit2();
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

### 4.5 运算符重载

运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型

#### 4.5.1 加号运算符重载

作用：实现两个自定义数据类型相加的运算

```c++
#include <iostream>
using namespace std;

class Person
{
public:
    //成员函数重载+号
    Person operator+(Person &p){
        Person temp;
        temp.m_A=this->m_A+p.m_A;
        temp.m_B=this->m_B+p.m_B;
        return temp;
    }
    int m_A;
    int m_B;
};
//全局函数重载+号
//Person operator+(Person &p1,Person &p2)
//{
//    Person temp;
//    temp.m_A=p1.m_A+p2.m_A;
//    temp.m_B=p1.m_B+p2.m_B;
//    return temp;
//}
void test01(){
    Person p1;
    p1.m_A=10;
    p1.m_B=10;
    Person p2;
    p2.m_A=10;
    p2.m_B=10;
    //成员函数重载本质调用
    //Person p3=p1.operator+(p2);
    //全局函数重载本质调用
    //Person p3=operator+(p1,p2);
    Person p3=p1+p2;
    cout<<"p3.m_A="<<p3.m_A<<endl;
    cout<<"p3.m_B="<<p3.m_B<<endl;
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

#### 4.5.2 左移运算符重载

作用：可以输出自定义数据类型

```c++
#include <iostream>
using namespace std;

class Person{
    friend ostream& operator<<(ostream& out,Person &p);

public:
    Person(int a,int b)
    {
        this->m_A=a;
        this->m_B=b;
    }
private:
    //利用成员函数重载 左移运算符 p.operator<<(cout) 简化p<<cout
    //不会利用成员函数重载<<运算符，因为无法实现cout在左侧
    int m_A;
    int m_B;

};

//只能利用全局函数重载左移运算符
ostream & operator<<(ostream &out,Person &p)//本质operator<<（cout，p）简化cout<<p
{
    out<<"m_A="<<p.m_A<<"m_B="<<p.m_B<<endl;
    return out;
}
void test01()
{
    Person p(10,10);
//    p.m_A=10;
//    p.m_B=10;
    cout<<p;
    cout<<p<<"hello world"<<endl;
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

> 总结：重载左移运算符配合友元可以实现输出自定义数据类型

#### 4.5.3 递增运算符重载

作用：通过重载递增运算符，实现自己的整型数据

```c++
#include <iostream>
using namespace std;

//重载递增运算符

//自定义整型
class MyInteger
{
    friend ostream& operator<<(ostream& cout,MyInteger myint);
public:
    MyInteger()
    {
        m_Num=0;
    }
    //重载前置++运算符
    MyInteger& operator++()
    {
        //先进行++运算
        m_Num++;
        //再将自身做返回
        return *this;
    }
    //重载后置++运算符
    //void operator++(int) int代表占位参数，可以用于区分前置和后置递增
    MyInteger operator++(int)
    {
        //先 记录当时结果
        MyInteger temp=*this;
        //后 递增
        m_Num++;
        //最后将记录结果做返回
        return temp;
    }
private:
    int m_Num;
};
//重载<<运算符 返回引用是为了对一个数据进行递增操作
ostream& operator<<(ostream& cout,MyInteger myint)
{
    cout<<myint.m_Num;
    return cout;
}
void test01(){
    MyInteger myint;
    cout<<++(++myint)<<endl;
}

void test02(){
    MyInteger mint;
    cout<<mint++<<endl;
    cout<<mint<<endl;
}
int main() {
    test01();
    test02();
    system("pause");
    return 0;
}
```

> 总结：前置递增返回引用，后置递增返回值

#### 4.5.4 赋值运算符重载

c++编译器至少给一个类添加 4 个函数

- 默认构造函数(无参，函数体为空)
- 默认析构函数(无参，函数体为空)
- 默认拷贝构造函数，对属性进行值拷贝
- 赋值运算符 operator=，对属性进行值拷贝

如果类中有属性执行堆区，做赋值操作时也会出现深浅拷贝问题

示例：

```c++
#include <iostream>
using namespace std;

//赋值运算符重载
class Person
{
public:
    Person(int age)
    {
        //开辟年龄到堆区
        m_Age=new int(age);
    }
    ~Person(){
        if(m_Age!=NULL)
        {
            delete m_Age;
            m_Age=NULL;
        }
    }
    //重载 赋值运算符
    Person& operator=(Person &p)
    {
        //编译器是提供了浅拷贝
        //m_Age=p.m_Age;
        //应该先判断是否有属性在堆区，如果有先释放干净，然后在深拷贝
        if(m_Age!=NULL)
        {
            delete m_Age;
            m_Age=NULL;
        }
        //深拷贝
        m_Age=new int(*p.m_Age);
        //返回对象本身
        return *this;
    }
    int *m_Age;
};
void test01(){
    Person p1(18);
    Person p2(20);
    Person p3(30);
    p1=p2=p3;
    cout<<"p1年龄为："<<*p1.m_Age<<endl;
    cout<<"p2年龄为："<<*p2.m_Age<<endl;
    cout<<"p3年龄为："<<*p3.m_Age<<endl;
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

#### 4.5.5 关系运算符重载

作用：重载关系运算符，可以让两个自定义类型对象进行对比操作

示例：

```c++
#include <iostream>
using namespace std;

#include "string"
//重载关系运算符
class Person
{
public:
    Person(string name,int age){
        m_Name=name;
        m_Age=age;
    }
    //重载==号
    bool operator==(Person &p){
        if(this->m_Name==p.m_Name&&this->m_Age==p.m_Age){
            return true;
        }
        return false;
    }
    //重载!=号
    bool operator!=(Person &p){
        if(this->m_Name==p.m_Name&&this->m_Age==p.m_Age){
            return false;
        }
        return true;
    }
   string m_Name;
   int  m_Age;
};
void test01(){
    Person p1("Tom",18);
    Person p2("jim",18);
    if(p1==p2)
    {
        cout<<"p1和p2相等"<<endl;
    }
    else
    {
        cout<<"p1和p2不相等"<<endl;
    }
    if(p1!=p2)
    {
        cout<<"p1和p2不相等"<<endl;
    }
    else
    {
        cout<<"p1和p2相等"<<endl;
    }
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

#### 4.5.6 函数调用运算符重载

- 函数调用运算符()也可以重载
- 由于重载后使用的方式非常像函数的调用，因此称为仿函数
- 仿函数没有固定写法，非常灵活

```c++
#include <iostream>
using namespace std;

#include "string"
//函数调用运算符重载

//打印输出类
class myPrint
{
public:
    //重载函数调用运算符
    void operator()(string test)
    {
        cout<<test<<endl;
    }
};
class MyAdd
{
public:
    int operator()(int v1,int v2){
        return v1+v2;
    }
};
void test01(){
    myPrint mypint;
    mypint("hello world");//由于使用起来非常像函数调用，因此称为仿函数
}
int main() {
    test01();
    cout<<MyAdd()(100,100)<<endl;
    system("pause");
    return 0;
}
```

### 4.6 继承

**继承是面向对象三大特性之一**

我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性，这个时候我们就可以考虑利用继承的技术，减少重复代码

#### 4.6.1 继承的基本语法

示例：

```c++
#include <iostream>
using namespace std;
#include "string"

//普通实现页面
//继承的好处：减少重复代码
//语法：class 子类：继承方式 父类
//子类   也称为  派生类
//父类   也称为  基类
//继承页面实现
//公共的页面
class BasePage
{
public:
    void header()
    {
        cout<<"首页、公开课、登录、注册...(公共头部)"<<endl;
    }
    void footer(){
        cout<<"帮助中心、交流合作、站内地图...(公共底部)"<<endl;
    }
    void left(){
        cout<<"Java、Python、C++...(公共分类列表)"<<endl;
    }
};
class Java:public BasePage
{
public:
    void content(){
        cout<<"java视频下载"<<endl;
    }
};
class Python:public BasePage
{
public:
    void content(){
        cout<<"Python视频下载"<<endl;
    }
};
class Cpp:public BasePage
{
public:
    void content(){
        cout<<"Cpp视频下载"<<endl;
    }
};
void test01(){
    cout<<"Java下载视频页面如下："<<endl;
    Java ja;
    ja.header();
    ja.left();
    ja.content();
    ja.footer();
    cout<<"---------------------------"<<endl;
    cout<<"Python下载视频页面如下："<<endl;
    Python py;
    py.header();
    py.left();
    py.content();
    py.footer();
    cout<<"---------------------------"<<endl;
    cout<<"C++下载视频页面如下："<<endl;
    Cpp cp;
    cp.header();
    cp.left();
    cp.content();
    cp.footer();
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

总结：可以减少重复的代码

class A:public B;

A 类称为子类或派生类

B 类称为父类或基类

**派生类中的成员，包含两大部分**

一类是从基类继承过来的，一类是自己增加的成员

从基类继承过来的表现其共性，而新增的成员体现了其个性。

#### 4.6.2 继承方式

继承的语法：class 子类 ：继承方式 父类

继承方式一共有三种：

- 公共继承
- 保护继承
- 私有继承

| 继承方式/基类成员 | public 成员 | protected 成员 | private 成员 |
| ----------------- | ----------- | -------------- | ------------ |
| public 继承       | public      | protected      | 不可见       |
| protected 继承    | protected   | protected      | 不可见       |
| private 继承      | private     | private        | 不可见       |

#### 4.6.3 继承中的对象模型

问题：从父类继承过来的成员，哪些属于子类对象中？

示例：

```c++
#include <iostream>
using namespace std;
#include "string"

class Base
{
public:
    int m_A;
protected:
    int m_B;
private:
    int m_C;//私有成员只是被隐藏了，但是还是会继承下去
};

//公共继承
class Son :public Base
{
public:
    int m_D;
};
void test01(){
    //父类中所有非静态成员属性都会被子类继承下去
    //父类中私有成员属性 是被编译器给隐藏了，因此是访问不到的，但是确实被继承下去了
    cout<<"sizeof Son ="<< sizeof(Son)<<endl;
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

#### 4.6.4 继承中构造和析构顺序

子类继承父类后，当创建子类对象，也会调用父类的构造函数

问题：父类和子类的构造和析构顺序是谁先谁后？

示例：

```c++
#include <iostream>
using namespace std;

class Base
{
public:
    Base()
    {
        cout<<"Base构造函数"<<endl;
    }
    ~Base(){
        cout<<"Base析构函数"<<endl;
    }
};
class Son :public Base
{
public:
    Son()
    {
        cout<<"Son构造函数"<<endl;
    }
    ~Son(){
        cout<<"Son析构函数"<<endl;
    }
};


void test01(){
    //Base b;
    //继承中的构造和析构顺序如下：
    //先构造父类，在构造子类，析构的顺序与构造的顺序相反
    Son s;
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

#### 4.6.5 继承同名成员处理方式

问题：当子类与父类出现同名的成员，如何通过子类对象访问到子类或父类中同名的数据呢？

- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域

```c++
#include <iostream>
using namespace std;

class Base
{
public:
    Base()
    {
        m_A=100;
    }
    void func(){
        cout<<"base -func()调用"<<endl;
    }
    int m_A;
};
class Son:public  Base
{
public:
    Son()
    {
        m_A=300;
    }
    void func(){
        cout<<"son -func()调用"<<endl;
    }
    int m_A;
};
//同名成员属性处理
void test01(){
    Son s;
    cout<<"Son下m_A ="<<s.m_A<<endl;
    //如果通过子类对象  访问到父类中同名成员，需要加作用域
    cout<<"Base下m_A ="<<s.Base::m_A<<endl;
}
//同名成员函数处理
void test02(){
    Son s;
    s.func();//直接调用 调用是子类中的同名成员
    //如何调用父类中同名成员函数
    s.Base::func();
}
int main() {
    test01();
    test02();
    system("pause");
    return 0;
}
```

总结：

- 子类对象可以直接访问到子类中同名成员
- 子类对象加作用域可以访问到父类同名成员
- 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域还可以访问到父类中同名函数

#### 4.6.6 继承同名静态成员处理方式

问题：继承中同名的静态成员在子类对象上如何进行访问？

静态成员和非静态成员出现同名，处理方式一致

- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域

```c++
#include <iostream>
using namespace std;

class Base
{
public:
    static int m_A;
    static void func(){
        cout<<"Base-func void func()"<<endl;
    }
};
int Base::m_A=100;

class Son:public  Base
{
public:
    static int m_A;

    static void func(){
        cout<<"Son-func void func()"<<endl;
    }
};
int Son::m_A=100;

//同名静态成员属性
void test01(){
    //通过对象访问
    Son s;
    cout<<"对象访问son下m_A="<<s.m_A<<endl;
    cout<<"对象访问Base下m_A="<<s.Base::m_A<<endl;
    //通过类名访问
    cout<<"类名访问son下m_A="<<Son::m_A<<endl;
    cout<<"对象访问Base下m_A="<<Son::Base::m_A<<endl;
}
//同名静态成员函数
void test02(){
    //通过对象访问
    Son s;
    s.func();
    s.Base::func();
    //通过类名访问
    Son::func();
    Son::Base::func();
}
int main() {
    test01();
    test02();
    system("pause");
    return 0;
}
```

#### 4.6.7 多继承语法

**c++允许一个类继承多个类**

语法:class 子类 ：继承方式 父类 1，继承方式 父类 2...

多继承可能会引发父类中有同名成员出现，需要加作用域区分

**c++实际开发中不建议用多继承**

```c++
#include <iostream>
using namespace std;

class Base1
{
public:
    Base1(){
        m_A=100;
    }
    int m_A;
};
class Base2
{
public:
    Base2(){
        m_A=200;
    }
    int m_A;
};
//子类  需继承base1和base2
class Son:public Base1,public Base2
{
public:
    Son(){
        m_C=300;
        m_D=400;
    }
    int m_C;
    int m_D;
};

void test02(){
    Son s;
    cout<<"sizeof Son="<< sizeof(s)<<endl;
    cout<<"m_C="<< s.m_C<<endl;
    cout<<"m_D="<< s.m_D<<endl;
    cout<<"Base1::m_A="<<s.Base1::m_A<<endl;
    cout<<"Base2::m_A="<<s.Base2::m_A<<endl;
}
int main() {
    test02();
    system("pause");
    return 0;
}
```

> 总结：多继承中如果父类中出现了同名情况，子类使用需要加作用域

#### 4.6.8 菱形继承

菱形继承概念：

- 两个派生类继承同一个基类
- 又有某个类同时继承两个派生类
- 这种继承称为菱形继承，或者钻石继承

```c++
#include <iostream>
using namespace std;
//动物类
class Animal{
public:
    int m_Age;
};
//继承之前 加上关键字 virtual变为虚继承
//羊类
class Sheep:virtual public Animal{};
//驼类
class Tuo :virtual public Animal{};
//羊驼类
class SheepTuo :public Sheep,public Tuo{};
void test02(){
    SheepTuo st;
    st.Sheep::m_Age=18;
    st.Tuo::m_Age=28;
    cout<<"st.Sheep::m_Age ="<<st.Sheep::m_Age<<endl;
    cout<<"st.Tuo::m_Age ="<<st.Tuo::m_Age<<endl;
    cout<<"st.m_Age ="<<st.m_Age<<endl;
}
int main() {
    test02();
    system("pause");
    return 0;
}
```

总结：

- 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费毫无意义
- 利用虚继承可以解决菱形继承的问题

### 4.7 多态

#### 4.7.1 多态的基本概念

**多态是 c++面向对象三大特性之一**

多态分为两类：

- 静态多态：函数重载和运算符重载属于静态多态，复用函数名
- 动态多态：派生类和虚函数实现运行时多态

静态多态和动态多态区别：

- 静态多态是函数地址早绑定-编译阶段确定函数地址
- 动态多态的函数地址晚绑定-运行阶段确定函数地址

```c++
#include <iostream>
using namespace std;
//多态
//动物类
class Animal
{
public:
    //虚函数
    virtual void speak()
    {
        cout<<"动物在说话"<<endl;
    }
};
//猫类
class Cat :public Animal
{
public:
    //重写  函数返回值类型  函数名  参数列表  完全相同
    virtual void speak()
    {
        cout<<"小猫在说话"<<endl;
    }
};
//狗类
class Dog :public Animal
{
   void speak(){
       cout<<"小狗在说话"<<endl;
   }
};
//执行说话的函数
//地址早绑定 在编译阶段确定函数地址
//如果想执行让猫说话，name这个函数地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定

//动态多态满足条件
//1.有继承关系
//2.子类重写父类的虚函数

//动态多态使用
//父类的指针或者引用 指向子类对象
void doSpeak(Animal &animal) //Animal &animal=cat;
{
    animal.speak();
}
void test01(){
    Cat cat;
    doSpeak(cat);

    Dog dog;
    doSpeak(dog);
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

动态多态满足条件：

- 有继承关系
- 子类重写父类的虚函数

动态多态使用

- 父类指针或引用指向子类对象

重写：函数返回值类型 函数名 参数列表 完全一致称为重写

#### 4.7.2 多态案例一，计算器类

案例描述：

分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类

多态的有点：

- 代码组织结构清晰
- 可读性强
- 利用前期和后期的扩展以及维护

```c++
#include <iostream>
using namespace std;
//普通写法
#include "string"
class Calculator
{
public:
    int getResult(string oper)
    {
        if(oper=="+")
        {
            return num1+num2;
        }
        else if(oper=="-")
        {
            return num1-num2;
        }
        else if(oper=="*")
        {
            return num1*num2;
        }
        else if(oper=="/")
        {
            return num1/num2;
        }
    }
    int num1;
    int num2;
};
//多态写法
class AbstractCalculator
{
public:
    virtual int getResult()
    {
        return 0;
    }
    int num1;
    int num2;
};
//加法类
class AddCalulator :public AbstractCalculator
{
    int getResult(){
        return num1+num2;
    }
};
//减法类
class SubCalulator :public AbstractCalculator
{
    int getResult(){
        return num1-num2;
    }
};
//减法类
class MulCalulator :public AbstractCalculator
{
    int getResult(){
        return num1*num2;
    }
};
//除法类
class DivCalulator :public AbstractCalculator
{
    int getResult(){
        return num1/num2;
    }
};
void test01()
{
    Calculator c;
    c.num1=10;
    c.num2=10;
    cout<<"num1+num2 ="<<c.getResult("+")<<endl;
    cout<<"num1-num2 ="<<c.getResult("-")<<endl;
    cout<<"num1*num2 ="<<c.getResult("*")<<endl;
    cout<<"num1/num2 ="<<c.getResult("/")<<endl;
}
void test02(){
    //多态使用条件
    //父类指针或者引用指向子类对象
    //加法
    AbstractCalculator *abc=new AddCalulator;
    abc->num1=10;
    abc->num2=10;
    cout<<"num1+num2 ="<<abc->getResult()<<endl;
    delete abc;
    //减法
    abc=new SubCalulator;
    abc->num1=10;
    abc->num2=10;
    cout<<"num1-num2 ="<<abc->getResult()<<endl;
    delete abc;
    //乘法
    abc=new MulCalulator;
    abc->num1=10;
    abc->num2=10;
    cout<<"num1*num2 ="<<abc->getResult()<<endl;
    delete abc;
    //除法
    abc=new DivCalulator;
    abc->num1=10;
    abc->num2=10;
    cout<<"num1/num2 ="<<abc->getResult()<<endl;
    delete abc;

}
int main() {
//    test01();
    test02();
    system("pause");
    return 0;
}
```

#### 4.7.3 纯虚函数和抽象类

在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容

因此可以将虚函数改为纯虚函数

纯虚函数语法：virtual 返回值类型 函数名 (参数列表)=0；

抽象类特点：

- 无法实例化对象
- 子类必须重写抽象类中的纯虚函数，否则也书序抽象类

```c++
#include <iostream>
using namespace std;

class Base
{
public:
    //纯虚函数
    //只要有一个纯虚函数，这个类称为抽象类
    //抽象类的特点：
    //1、无法实例化对象
    //2、抽象类的子类 必须要重写父类中的纯虚函数，否则也属于抽象类
    virtual void func()=0;
};
class Son :public Base
{
public:
    virtual void func(){
        cout<<"func函数调用"<<endl;
    };
};
void test01(){
    //Son s;//子类必须重写父类中的纯虚函数，否则也属于抽象类
    Base *base=new Son;
    base->func();
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

#### 4.7.4 多态案例二，制作饮品

案例描述：

制作饮品的大致流程为：煮水-冲泡-倒入杯中-加入辅料

利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶

```c++
#include <iostream>
using namespace std;

class AbstractDringking
{
public:
    //煮水
    virtual void boil()=0;
    //冲泡
    virtual void dBrew()=0;
    //倒入杯中
    virtual void PourInCup()=0;
    //加入辅料
    virtual void PutSomething()=0;
    //制作饮品
    void makeDrink()
    {
        boil();
        dBrew();
        PourInCup();
        PutSomething();
    }
};
//制作咖啡
class Coffee :public AbstractDringking
{
public:
    //煮水
    virtual void boil(){
        cout<<"煮农夫山泉"<<endl;
    };
    //冲泡
    virtual void dBrew(){
        cout<<"冲泡咖啡"<<endl;
    };
    //倒入杯中
    virtual void PourInCup(){
        cout<<"倒入杯中"<<endl;
    };
    //加入辅料
    virtual void PutSomething(){
        cout<<"加入糖，牛奶"<<endl;
    };
};
//制作咖啡
class Tea :public AbstractDringking
{
public:
    //煮水
    virtual void boil(){
        cout<<"煮矿泉水"<<endl;
    };
    //冲泡
    virtual void dBrew(){
        cout<<"冲泡茶叶"<<endl;
    };
    //倒入杯中
    virtual void PourInCup(){
        cout<<"倒入杯中"<<endl;
    };
    //加入辅料
    virtual void PutSomething(){
        cout<<"加入枸杞"<<endl;
    };
};
//制作函数
void doWork(AbstractDringking * abs)
{
    abs->makeDrink();
    delete abs;//释放
}
void test01(){
    cout<<"----------制作咖啡----------"<<endl;
    doWork(new Coffee);
    cout<<"----------制作茶叶----------"<<endl;
    doWork(new Tea);
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

#### 4.7.5 虚析构和纯虚析构

多态使用是，如果子类中有属性开辟到堆区，name 父类指针在释放是无法调用到子类的析构代码

解决方式：将父类中的析构函数改为虚析构或者纯虚析构

虚析构和纯虚析构共性：

- 可以解决父类指针释放子类对象
- 都需要有具体的函数实现

虚析构和纯虚析构的区别：

- 如果是纯虚析构，该类属于抽象类，无法实例化对象

虚析构语法：

**virtual ~类名(){}**

纯虚析构语法：

**virtual ~类名()=0;**

**类名::~类名(){}**

```c++
#include <iostream>
using namespace std;

#include "string"

class Animal
{
public:
    Animal(){
        cout<<"animal构造函数调用"<<endl;

    }
    //利用虚析构可以解决 父类指针释放子类对象是不干净的问题
//    virtual ~Animal(){
//        cout<<"animal析构函数调用"<<endl;
//    }
    //纯虚析构
    //有了纯虚析构之后，这个类也属于抽象类，无法实例化对象
    virtual ~Animal() =0;
    //纯虚函数
    virtual void speak()=0;
};
Animal::~Animal() {
    cout<<"animal纯虚析构函数调用"<<endl;
}
class Cat :public Animal
{
public:
    Cat(string name){
        cout<<"Cat构造函数"<<endl;
        m_name=new string(name);
    }
    virtual void speak(){
        cout<<*m_name<<"小猫在说话"<<endl;
    }
    ~Cat(){
        if(m_name!=NULL)
        {
            cout<<"Cat析构函数"<<endl;
            delete m_name;
            m_name=NULL;
        }
    }
    string *m_name;
};

void test01(){
    Animal * animal=new Cat("Tom");
    animal->speak();
    //父类指针在析构时候不会调用子类中析构函数，导致子类如果有堆区属性，出现内存泄漏
    delete animal;
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

总结：

> 1.虚析构后纯虚析构就是用来解决通过父类指针释放子类对象
>
> 2.如果子类中没有堆区数据，可以不写为虚析构或纯虚析构
>
> 3.拥有纯虚析构函数的类也属于抽象类

#### 4.7.6 多态案例三，电脑组装

案例描述：

电脑主要组成部件为 CPU(用于计算),显卡(用于显示),内存条(用于存储)，将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，泪如 intel 厂商和 Lenovo 厂商。

创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口

测试时组装三台不同的电脑进行工作

```c++
#include <iostream>
using namespace std;

#include "string"
//抽象不同零件类
//抽象CPU类
class Cpu
{
public:
    //抽象的计算函数
    virtual void calculate()=0;
};
//抽象显卡类
class VideoCard
{
public:
    //抽象的显示函数
    virtual void display()=0;
};
//抽象内存条类
class Memory
{
public:
    //抽象的存储函数
    virtual void storage()=0;
};
//电脑类
class Computer
{
public:
    Computer(Cpu *cpu,VideoCard *vc,Memory *mem)
    {
        m_cpu=cpu;
        m_vc=vc;
        m_mem=mem;
    }
    //提供工作函数
    void work()
    {
        m_cpu->calculate();

        m_vc->display();

        m_mem->storage();
    }
    //提供析构函数  释放3个电脑零件
    ~Computer()
    {
        if(m_cpu!=NULL)
        {
            delete m_cpu;
            m_cpu=NULL;
        }
        if(m_vc!=NULL)
        {
            delete m_vc;
            m_vc=NULL;
        }
        if(m_mem!=NULL)
        {
            delete m_mem;
            m_mem=NULL;
        }
    }
private:
    Cpu *m_cpu;//CPU的零件指针
    VideoCard *m_vc;//显卡零件指针
    Memory *m_mem;//内存条零件指针
};
//具体厂商
class IntelCpu :public Cpu
{
public:
    virtual void calculate()
    {
        cout<<"Intel的CPU开始计算了！"<<endl;
    }
};
class IntelVideoCard :public VideoCard
{
public:
    virtual void display()
    {
        cout<<"Intel的显示屏开始显示了！"<<endl;
    }
};
class IntelMemory :public Memory
{
public:
    virtual void storage()
    {
        cout<<"Intel的内存条开始存储了！"<<endl;
    }
};

class LenovoCpu :public Cpu
{
public:
    virtual void calculate()
    {
        cout<<"Lenovo的CPU开始计算了！"<<endl;
    }
};
class LenovoVideoCard :public VideoCard
{
public:
    virtual void display()
    {
        cout<<"Lenovo的显示屏开始显示了！"<<endl;
    }
};
class LenovoMemory :public Memory
{
public:
    virtual void storage()
    {
        cout<<"Lenovo的内存条开始存储了！"<<endl;
    }
};

void test01(){
    //第一台电脑零件
    Cpu * intelCpu=new IntelCpu;
    VideoCard * intelCard=new IntelVideoCard;
    Memory * intelMemory=new IntelMemory;

    //创建第一台电脑
    Computer *c1=new Computer(intelCpu,intelCard,intelMemory);
    c1->work();
    delete c1;
    //创建第二台电脑
    Computer *c2=new Computer(new LenovoCpu,new LenovoVideoCard,new LenovoMemory);
    c2->work();
    delete c1;
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

## 5 文件操作

程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放

通过文件可以将数据持久化

c++中对文件操作需要包含头文件<fstream>

文件类型分为两种：

1.**文本文件** 文件以文本的 ASCII 码形式存储在计算机中

2.**二进制文件** 文件以文本的二进制形式村粗在计算机中，用户一般不能直接读懂他们

操作文件的三大类：

- ofstream:写操作
- ifstream：读操作
- fstream：读写操作

### 5.1 文本文件

#### 5.1.1 写文件

写文件步骤如下：

1.包含头文件

> #include <fstream>

2.创建流对象

> ofstream ofs;

3.打开文件

> ofs.open("文件路径",打开方式)

4.写数据

> ofs<<"写入得数据"

5.关闭文件

> ofs.close();

文件打开方式：

|  打开方式   |            解释            |
| :---------: | :------------------------: |
|   ios::in   |     为读文件而打开文件     |
|  ios::out   |     为写文件而打开文件     |
| ios::binary |         二进制方式         |
|  ios::app   |       追加方式写文件       |
| ios::trunc  | 如果文件存在先删除，在创建 |
|  ios::ate   |     初始文职：文件末尾     |

注意：文件打开方式可以配合使用，利用 |操作符

列如：用二进制方式写文件 ios::binary | ios::out

```c++
#include <iostream>
using namespace std;

#include <fstream>
//文本文件  写文件
void test01()
{
    //1.包含头文件 fstream
    //2.创建流对象
    ofstream ofs;
    //3.指定打开方式
    ofs.open("test.txt",ios::out);
    //4.写内容
    ofs<<"姓名：张三"<<endl;
    ofs<<"性别：男"<<endl;
    ofs<<"年龄：18"<<endl;

    //5.关闭文件
    ofs.close();
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

总结：

- 文件操作必须宝行头文件 fstream
- 读文件可以利用 ofstream，或者 fstream 类
- 打开文件时候需要制定操作文件的路径，以及打开方式
- 利用<<可以向文件写数据
- 操作完毕，要关闭文件

#### 5.1.2 读文件

读文件与写文件步骤相似，但是读取方式相对于比较多

读文件步骤如下：

1.包含头文件

#incalude <fstream>

2.创建流对象

ifstream ifs;

3.打开文件并判断文件是否打开成功

ifs.open("文件路径",打开方式)

4.读数据

四种方式读取

5.关闭文件

ifs.close();

```c++
#include <iostream>
using namespace std;

#include <fstream>
#include "string"
//文本文件  读文件
void test01()
{
   //包含头文件
   //创建流对象
   ifstream ifs;
   //打开文件  并且判断是否打开成功
   ifs.open("test.txt",ios::in);
   if(!ifs.is_open())
   {
       cout<<"文件打开失败"<<endl;
       return;
   }
   //读数据
    //第一种
//   char buf[1024]={0};
//   while (ifs>>buf)
//   {
//       cout<<buf<<endl;
//   }
    //第二种
//   char buf[1024]={0};
//   while(ifs.getline(buf, sizeof(buf)))
//   {
//       cout<<buf<<endl;
//   }
    //第三种
//   string buf;
//   while(getline(ifs,buf))
//   {
//       cout<<buf<<endl;
//   }
    //第四种
   char c;
   while((c=ifs.get())!=EOF) //EOF  end of file
   {
       cout<<c;
   }
   //关闭文件
   ifs.close();
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

总结：

- 读文件可以利用 ifstream，或者 fstream 类
- 利用 is_open 函数可以判断文件是否打开成功
- close 关闭文件

### 5.2 二进制文件

以二进制的方式对文件进行读写操作

打开方式要指定为 ios::binary

#### 5.2.1 写文件

二进制方式写文件主要利用流对象调用成员函数 write

函数原型：ostream& write(const char \* buffer,int len)

参数解释：字符指针 buffer 指向内存中一段存储空间，len 是读写文件的字节数

```c++
#include <iostream>
using namespace std;

#include <fstream>
//二进制文件  写文件
class Person
{
public:
    char m_Name[64]; //姓名
    int m_Age;//年龄
};
void test01()
{
    //1.包含头文件
    //创建流对象
    ofstream ofs("person.txt",ios::out | ios::binary);
    //写文件
    Person p={"张三",18};
    ofs.write((const char *)&p, sizeof(Person));
    //关闭文件
    ofs.close();
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

总结：

- 文件输出流对象 可以通过 write 函数，以二进制方式写数据

#### 5.2.2 读文件

二进制方式读文件主要利用流对象调用成员函数 read

函数原型：istream& read(char \*buffer,int len)

参数解释：字符指针 buffer 指向内存中一段存储空间，len 是读写的字节数

```c++
#include <iostream>
using namespace std;

#include <fstream>
//二进制文件  读文件
class Person
{
public:
    char m_Name[64]; //姓名
    int m_Age;//年龄
};
void test01()
{
    //包含头文件
    //创建流对象
    ifstream ifs;
    //打开文件 判断文件是否打开成功
    ifs.open("person.txt",ios::in | ios::binary);
    if(!ifs.is_open())
    {
        cout<<"文件打开失败"<<endl;
        return;
    }
    //读文件
    Person p;
    ifs.read((char *)&p, sizeof(Person));
    cout<<"姓名："<<p.m_Name<<" 年龄:"<<p.m_Age<<endl;
    //关闭文件
    ifs.close();
}
int main() {
    test01();
    system("pause");
    return 0;
}
```

- 文件输入流对象 可以通过 read 函数，以二进制方式读数据
