[toc]

<div align="center"><font size="35">IPC(inter-Process Communication)共享内存</font></div>

# 1: 共享内存的定义

- [linux--共享内存函数（shmget、shmat、shmdt、shmctl）及其范例](https://blog.csdn.net/qq_38880380/article/details/79444713)

- **IPC** (Inter-Process Communication) 共享内存是一种进程间通信机制，允许两个或多个进程共享一段内存区域。 这意味着，当一个进程对共享内存区域进行修改时，其他进程可以立即看到这些修改。
- IPC 共享内存是一种高效的通信方式，因为它避免了在进程间传递大量数据所带来的开销。相反，进程只需要在共享内存区域内读写数据即可。
- 在 Linux 系统中，可以使用 **`shmget、shmat 、shmdt以及shmctl`** 等函数来创建、映射和解除映射共享内存区域。在其他操作系统中，可能需要使用类似的函数或者系统调用来使用 IPC 共享内存。

# 2：共享内存的使用

- 调用函数 `shmget` 创建一个新共享内存或者取得一个既有共享内存段的标识符;
- 调用 `shmat` 将共享内存附加到当前进程的虚拟地址空间中;
- 为了引用共享内存，程序需要由 shmat 函数返回的 addr 值，这个是一个指向进程的虚拟地址空间中该共享内存段起点的指针;
- 调用 `shmdt` 分离共享内存段;
- 调用函数 `shmctl` 删除共享内存段。

# 3：IPC 共享内存的思考点

## 3.1 IPC 常见的问题

- **同步问题**: 在进程间通信时，如果一个进程正在读取共享内存中的数据，而另一个进程正在向共享内存中写入数据，这就可能导致数据不一致的问题。
  为了解决这个问题，我们通常需要使用同步机制，例如互斥量或信号量来协调进程间的读写操作;
- **安全问题**:
  IPC 共享内存的数据是所有进程都可以访问的，因此它存在安全风险。如果一个进程对共享内存的数据进行了非法修改，可能会导致其他进程的程序错误或者数据不一致的问题。为了解决这个问题，我们需要对共享内存设置访问权限，以防止不合法的进程访问;
- **性能问题**: IPC 共享内存的数据传输速度比其他进程间通信方式快，但是在大量数据传输的情况下，IPC 共享内存的性能可能会受到限制。这是因为，在多个进程同时访问共享内存的情况下，内存的访问冲突可能会导致性能下降;
- **资源限制问题**: 在使用 IPC 共享内存的时候，需要申请一段共享内存，这就会占用系统内存资源。如果系统内存资源有限，那么就可能导致共享内存申请失败的情况;
- **程序复杂性问题**: 使用 IPC 共享内存进行进程间通信需要对进程间同步和数据传输进行较多的编程，这会使程序变得更加复杂。

## 3.2 超过共享内存大小限制怎么办

如果共享内存的大小超过了系统的限制，那么在大多数情况下，系统会返回一个错误代码，表示申请共享内存失败。
这时，可以采取以下几种方式来解决问题：

- 减少共享内存的大小：如果共享内存的大小过大，可以考虑减少共享内存的大小，以便申请到更多的内存。
- 改用其他进程间通信方式：如果申请共享内存失败，可以考虑使用其他进程间通信方式，例如管道、消息队列、信号等。
- 使用虚拟内存：如果系统开启了虚拟内存，那么可以使用虚拟内存来解决内存不足的问题。虚拟内存是指由硬盘虚拟出来的内存，在内存不足的情况下可以使用虚拟内存来代替内存。

## 3.3 同一个进程多次进行 shmat 会出现什么问题

当首次创建共享内存段时，它不能被任何进程所访问，为了使共享内存区可以被访问，则必须通过 shmat 函数将其附加到自己的进程空间中。这样进程就与共享内存建立了连接。
这样挂载一个共享内存如果是第一次调用时没有问题的，但是一个进程是可以对同一个共享内存多次 shmat 进行挂载的，物理内存是指向同一块，如果 shmaddr 为
NULL,则每次返回的线性地址空间都不同，而且指向这块共享内存的引用计数会增加，也就是进程多块线性空间会指向同一块物理地址，这样会一直消耗进程的虚拟内存空间，很有可能会最后导致进程线性空间被使用完，而导致下次 shmat 或者其他操作失败

## 3.4 进程消息队列通信——IPC-EXCL 出错

在 shmget（）创建操作是，可以指定 IPC-CREAT 和 IPC-EXCL 选项，当 IPC-CREAT 选项打开时，如果存在共享内存，返回 ID，如果不存在，创建共享内存，并返回 ID
当 IPC-EXCL 选项打开，ipc 资源已经存在，返回-1
shmget（mqkey，IPC-CREAT|IPC_EXCL|0666）得到的返回值为-1 出错

- 解决方法一：去除 IPC_EXCL
- 解决方法二：在创建之前，加上清除队列的代码，c 语言代码：msgctl(mqid,IPC RMID,NULL);
- 解决方法三：使用命令清除队列
- 使用 **`ipcs -a`** 查看 存在队列 $ipcs -q
                         使用IPCRM清除   $ipcrm -q 65536（65536是msqid）
                         最后可使用$ipcs -q 查看是否还存在队列（把所有存在队列清除，重新运行代码即可）
  推荐使用方法三，可以清除看清自己存在的队列，并一 一清除

# 4: IPC 优缺点总结

## 4.1 优点 advantages

- 采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于管道和消息队列而言，则需要在内核和用户空间进行四次数据拷贝，而共享内存只拷贝两次数据，一次从输入文件到共享内存区，另一次从共享内存区到输出文件。
- 共享内存可以用于任意两个进程之间的通信

## 4.2 缺点 disadvantages

- 共享内存没有提供同步机制，需要借助其他手段进行进程间的同步工作;
- 利用内存缓冲区之间交换信息，只能同一个计算机系统内的诸多进程共享。

# 5: 共享内存函数

> 共享内存函数由 shmget、shmat、shmdt、shmctl 四个函数组成。下面的表格列出了这四个函数的函数原型及其具体说明;

## 5.1 shmget 函数

- shmget(得到一个共享内存标识符或创建一个共享内存对象并返回共享内存标识符)；
- 所需头文件:

```cpp
  #include <sys/ipc.h>
  #include <sys/shm.h>
```

- 函数原型: `int shmget(key_t key, size_t size, int shmflg)`;
- 函数参数:
  - **key**:
    - 0(IPC_PRIVATE)：会建立新共享内存对象;
    - 大于 0 的 32 位整数：视参数 shmflg 来确定操作。通常要求此值来源于 ftok 返回的 IPC 键值;
  - **size**:
    - 大于 0 的整数：新建的共享内存大小，以字节为单位;
    - 0：只获取共享内存时指定为 0;
  - **shmflg**:
    - 0：取共享内存标识符，若不存在则函数会报错;
    - IPC_CREAT：当 shmflg&IPC_CREAT 为真时，如果内核中不存在键值与 key 相等的共享内存，则新建一个共享内存；如果存在这样的共享内存，返回此共享内存的标识符;
    - IPC_CREAT|IPC_EXCL：如果内核中不存在键值与 key 相等的共享内存，则新建一个消息队列；如果存在这样的共享内存则报错;
- 函数返回值:
  - 成功: 返回共享内存的标识符;
  - 出错: -1，错误原因存于 error 中;
- 错误代码:
  - EINVAL：参数 size 小于 SHMMIN 或大于 SHMMAX
  - EEXIST：预建立 key 所指的共享内存，但已经存在
  - EIDRM：参数 key 所指的共享内存已经删除
  - ENOSPC：超过了系统允许建立的共享内存的最大值(SHMALL)
  - ENOENT：参数 key 所指的共享内存不存在，而参数 shmflg 未设 IPC_CREAT 位
  - EACCES：没有权限
  - ENOMEM：核心内存不足
